# Generate Implementation Plan

Create a detailed implementation plan from the current spec.

## Instructions

1. Read current task from `.branch-flow/current-task.json`
   - If no active task, prompt to run `/bf:spec` first

2. Read the spec file from `.branch-flow/specs/`

3. Read memory files for project context:
   - `.branch-flow/memory/project-context.md`
   - `.branch-flow/memory/decisions.md`
   - `.branch-flow/memory/learnings.md`

4. **Codebase Analysis Phase:**
   - Identify files that will need modification
   - Find related existing code patterns
   - Check for existing tests to understand testing patterns
   - Look for similar features already implemented
   - Note any potential conflicts or considerations
   - Use `/bf:search` for semantic search if helpful

5. **Dependency Detection Phase:**
   - Scan for external libraries/frameworks involved
   - Check package.json, requirements.txt, etc.
   - Identify APIs that will need documentation reference
   
   If external dependencies found:
   ```
   ğŸ“š This task involves external libraries:
      - react-query (data fetching)
      - zod (validation)
   
   Fetch latest documentation? (y/n/select)
   > y
   ```
   
   If yes, for each:
   - Use Context7 MCP to fetch docs
   - Extract only relevant APIs (see docs-research skill)
   - Save to `.branch-flow/docs/[library]-ref.md`
   - Keep summaries concise (~50-100 lines each)

6. **Planning Phase** - Create atomic, ordered tasks:
   - Each task should be completable in one focused session
   - Tasks should be ordered by dependency
   - Include test tasks (TDD when appropriate)
   - Consider edge cases and error handling

6. Create plan file `.branch-flow/plans/[spec-id]-plan.md`:

```markdown
# Implementation Plan: [Spec Title]

**Spec:** [spec-id]
**Created:** [date]
**Estimated Tasks:** [count]

## Analysis

### Files to Modify
- `path/to/file1.ts` - [what changes]
- `path/to/file2.ts` - [what changes]

### Files to Create
- `path/to/new-file.ts` - [purpose]

### Dependencies
- [package/module] - [why needed, if adding]

### Patterns to Follow
Based on existing codebase:
- [pattern 1 from similar feature]
- [pattern 2 from conventions]

### Documentation References
| Library | Reference | Key APIs |
|---------|-----------|----------|
| react-query | docs/react-query-ref.md | useQuery, useMutation |
| zod | docs/zod-ref.md | z.object, z.string |

*Note: Concise references stored in .branch-flow/docs/*

## Implementation Tasks

### Task 1: [Name]
**Type:** setup | feature | test | refactor | docs
**Files:** file1.ts, file2.ts
**Description:**
[Detailed description of what to do]

**Checklist:**
- [ ] Step 1
- [ ] Step 2
- [ ] Verify: [how to verify this task is complete]

---

### Task 2: [Name]
**Type:** test
**Files:** file1.test.ts
**Description:**
Write tests for [feature]

**Checklist:**
- [ ] Test case 1
- [ ] Test case 2
- [ ] Run tests and verify passing

---

### Task 3: [Name]
...

## Verification Checklist

Before marking complete:
- [ ] All acceptance criteria from spec met
- [ ] Tests written and passing
- [ ] Linting passes
- [ ] No regressions in existing tests
- [ ] Code reviewed against spec
- [ ] Documentation updated if needed

## Rollback Plan

If issues arise:
- [How to safely revert changes]
- [What to check before rollback]

---
*Plan generated by Branch Flow*
```

7. Update current-task.json:
```json
{
  "specId": "001",
  "specFile": "001-feature-name.md",
  "planFile": "001-plan.md",
  "status": "planned",
  "createdAt": "...",
  "plannedAt": "...",
  "branch": null,
  "currentTask": 0,
  "totalTasks": 5
}
```

8. Output:
```
ğŸ“‹ Implementation Plan Created

ğŸ“„ Spec: 001-[name]
ğŸ“„ Plan: .branch-flow/plans/001-plan.md

ğŸ“Š Analysis:
   Files to modify: [count]
   Files to create: [count]
   
ğŸ“ Tasks: [count] implementation tasks

### Task Overview:
1. [Task 1 name] (setup)
2. [Task 2 name] (test)
3. [Task 3 name] (feature)
...

Next: Review the plan, then run /bf:build to start implementation
```

## Planning Principles

- **Atomic tasks**: Each task is self-contained
- **Test early**: Write tests before or alongside implementation
- **Incremental**: Each task builds on previous
- **Verifiable**: Each task has clear completion criteria
- **Ordered by dependency**: No task requires incomplete work
